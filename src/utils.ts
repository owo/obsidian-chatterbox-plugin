let DECODE_TEXT_AREA: HTMLTextAreaElement | undefined = undefined;

/**
 * Decodes HTML entities from a given source string.
 * 
 * @param source Source string containing HTML entities.
 * @returns Source string with HTML entities decoded.
 */
export function decodeHTMLEntities(source: string) {
    if (source.indexOf("&") === -1) {
        return source;
    }

    if (DECODE_TEXT_AREA === undefined) {
        DECODE_TEXT_AREA = document.createElement("textarea");
    }

    // eslint-disable-next-line @microsoft/sdl/no-inner-html
    DECODE_TEXT_AREA.innerHTML = source;

    const decoded = DECODE_TEXT_AREA.textContent;

    DECODE_TEXT_AREA.innerHTML = "";

    return decoded;
}

/**
 * Applies visual fixes to HTML rendered by Obsidian's `MarkdownRenderer`.
 * 
 * @param el The HTML element containing Obsidian-rendered markdown.
 */
export function fixObsidianRenderedMarkdown(el: HTMLElement) {
    let foundFirst: boolean = false;
    let firstEl: HTMLElement | null = null;
    let lastEl: HTMLElement | null = null;

    // Remove last empty paragraph generated by MarkdownRenderer when an HTML block element is
    // present in the input.
    const lastChild = el.childNodes[el.childNodes.length - 1];
    if (lastChild.nodeType === Node.ELEMENT_NODE) {
        const lastChildEl = lastChild as HTMLElement;
        if (lastChildEl.tagName === "P" && lastChildEl.innerHTML.trim().length === 0) {
            el.removeChild(lastChild);
        }
    }

    // Walk from the start, ignoring whitespace-only text and comments
    for (const n of el.childNodes) {
        const node = n as Node;

        // Ignore comment nodes
        if (node.nodeType === Node.COMMENT_NODE) {
            continue;
        }

        if (node.nodeType === Node.TEXT_NODE) {
            if (node.nodeValue !== null && node.nodeValue.trim() === "") {
                continue;
            }

            if (!foundFirst) {
                foundFirst = true;
            }

            foundFirst = true;

            if (lastEl !== null) {
                lastEl = null;
            }
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
            const childEl = node as HTMLElement;

            if (!foundFirst) {
                foundFirst = true;
                firstEl = childEl;
            }

            lastEl = childEl;
        }
    }

    if (firstEl !== null) {
        firstEl.classList.add("cbx-md-fix-first");
    }

    if (lastEl !== null) {
        lastEl.classList.add("cbx-md-fix-last");
    }
}
